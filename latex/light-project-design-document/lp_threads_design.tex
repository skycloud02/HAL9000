\documentclass[a4paper,12pt]{report}
\usepackage{listings}
\usepackage{xcolor}
\lstset{
	language=C,
	basicstyle=\footnotesize\ttfamily,
	keywordstyle=\bfseries,
	commentstyle=\itshape,
	escapechar=\,
	emphstyle=\bfseries\color{red}
 	commentstyle=\slshape\color{green!50!black},
 	keywordstyle=\bfseries\color{blue!50!black},
 	identifierstyle=\color{blue},
 	stringstyle=\color{orange},
	showstringspaces=false
}


\title{Light Project Design For The THREADS Module}

\author{Students' Name}

\begin{document}

\begin{abstract}
    This document contains the design for the changes required to implement the light project specification  of the threads module of the HAL9000 operating system. 
    
    The document was created as a task for the Operating Systems Design subject taught at the Technical University of Cluj-Napoca. 
    
    \textcolor{red}{The document has some sections that are intentionally left for you to fill in. This sections are marked with red. Fill them in before you deliver your assignment.}
    
\end{abstract}



\maketitle

%% -----------------
%% -----------------
\chapter{Assignment requirements}

%% -----------------
\section{Initial Functionality}
    The HAL9000 operating system supports multi-core processors. After boot, each core is allowed to run operating system threads. 
    
    Functions to manage threads are implemented in the \textit{thread.c} file. The \textit{thread.h} file contains a documented public interface for the thread functionality.
    
    Information about threads are stored internally in the \lstinline|_THREAD| structure defined in \textit{thread\_internal.h}. This structure is reference counted. The \lstinline|_ThreadDestry| function frees the memory for a \lstinline|_THREAD| structure whenever the reference count of it reaches 0.
    
    All threads in the system are stored in the \lstinline|m_threadSystemData.AllThreadsList| list. This list is protected by the \lstinline|m_threadSystemData.AllThreadsLock|.

\subsection{Thread identifiers}
    The thread identifier is stored in the \lstinline|_THREAD| structure as the \lstinline|TID Id| field. 
    
    Code that initializes the Id of each thread is contained inside the \lstinline|_ThreadInit| function:
    \begin{lstlisting}
     pThread->Id = _ThreadSystemGetNextTid();
    \end{lstlisting}
    
    The \lstinline|_ThreadSystemGetNextTid| function is responsible with generating new thread identifiers. Thread identifiers are generated by atomically adding \lstinline{TID_INCREMENT} to the last id generating by the function. The initial implementation sets \lstinline|TID_INCREMENT| to 4. 
    
    Information about the current CPU is stored in the \lstinline|_PCPU| structure defined in \lstinline|cpumu.h| header file. A pointer to the structure corresponding to the current CPU may be obtained using the \lstinline|GetCurrentPcpu| macro. 

\subsection{Account for number of threads created}
    The \lstinline|ThreadCreateEx| is used to create new threads to run on HAL900. This function allocates and sets up the \lstinline|_THREAD| structure for the newly created thread. The function is always executed in the context of the parent that creates the thread. 

    The \lstinline|ThreadExit| function is called whenever a thread terminates. HAL9000 assures that this function is always called by wrapping threads inside the \lstinline|_ThreadKernelFunction| function. 
    
\subsection{Task 3: Round robin scheduler}
    HAL9000 implements a round robin scheduler strategy based on timer interrupts. When a timer interrupt is generated on the processor, the interrupt handler eventually calls the \lstinline|ThreadTick| function. If a thread spent more then \lstinline|THREAD_TIME_SLICE| ticks on the processor, the scheduler forces it to yield execution. 
    
    The \lstinline{_ThreadSchedule} function is responsible with selecting the next thread to run on the CPU. 

%% -----------------
\section{Requirements}

\subsection{Thread identifiers}
We are required to perform two changes:
\begin{itemize}
    \item change the way thread identifiers are allocated, such that the values used for the field Id in structure THREAD to be multiples of 5
    \item store the identifier of the CPU the thread was created on.
\end{itemize}

\subsection{Account for number of threads created}

We are required to print two messages as follows. 

On thread creation:  "Thread [ID=NEW\_TH\_ID] is the Xth thread created by thread [ID=CRT\_TH\_ID] on CPU [ID=CRT\_CPU\_ID]", where \lstinline|NEW_TH_ID| is the identifier of the newly created thread, \lstinline|CRT_TH_ID| is the identifier of the currently running thread, and \lstinline|CRT_CPU_ID| is the identifier of the current CPU. 

On thread exit: "Thread [ID=CRT\_TH\_ID] created on CPU [ID=CPU\_ID] is finishing on CPU [ID=CRT\_CPU\_ID], while its parent thread [ID=PR\_TH\_ID] still has more X child threads", where \lstinline|CRT_TH_ID| is the identifier of the currently terminating thread, \lstinline|PR_TH_ID| is the identifier current thread's parent, \lstinline|CPU_ID| is the ID of the CPU the thread was created on, and \lstinline|CRT_CPU_ID| is the ID of the CPU the thread is running during its termination.

For this we need to
\begin{itemize}
    \item know the parent of each thread
    \item count the number of threads created by each parent thread
    \item count the number of still running children of each thread
\end{itemize}


\subsection{ Round robin scheduler}

For this task we have three requirements:
\begin{itemize}
    \item allocate a the time quantum of 3 ticks for threads having an odd ID, and a time quantum of 6 ticks for threads having an even ID. 
    \item keep track of how many time quanta a thread was allocated until its completion. 
    \item when a thread terminates a message like "Thread [ID=CRT\_TH\_ID] was allocated X time quanta of length Y" must be displayed, where CRT\_TH\_ID is the ID of the terminating thread.
\end{itemize}

%% -----------------
%% -----------------
\chapter{Design Description}

%% -----------------
\section{Needed Data Structures and Functions}
\subsection{Thread identifiers}
We will store the CPU a thread was created on inside the \lstinline|_THREAD| structure. For this we will add a new field named \lstinline|CreationCpuApicId| inside the structure as follows:

\begin{lstlisting}
 typedef struct _THREAD
{
    ...
    APIC_ID CreationCpuApicId;
    ...
} THREAD, *PTHREAD;
\end{lstlisting}

We will need to modify the \lstinline|_ThreadInit| function to initialize this new field. 

\subsection{Account for number of threads created}

The messages will be added in the \lstinline|_ThreadInit| and \lstinline|_ThreadExit| functions. 

We will modify the \lstinline|_THREAD| structure to take note of the Id of the parent thread (\lstinline|ParentId|), the number of children created (\lstinline|NumberOfChildrenCreated|) and the number of active children the parent has (\lstinline|NumberOfActiveChildren|. 

The modified structure will change as follows:
\begin{lstlisting}
 typedef struct _THREAD
{
    ...
    TID   ParentId;
    ULONG         NumberOfChildrenCreated;
    volatile long NumberOfActiveChildren;
    ...
} THREAD, *PTHREAD;
\end{lstlisting}

We declare \lstinline{NumberOfActiveChildren} as volatile to use interlocked operations on it. 


We will initialize the newly added fields in \lstinline|_ThreadInit|. 

We will create a new function named \lstinline|_ThreadReferenceByTid| to allow us to retrieve the a pointer to the thread with a given ID. This function will be implemented in \lstinline|thread.c|. The header of the function is as follows:
\begin{lstlisting}
 PTHREAD _ThreadReferenceByTid(TID ThreadId);
\end{lstlisting}

\subsection{Round robin scheduler}
  \textcolor{red}{This subsection is left intentionally blank. It is your task to fill this section in before presenting the document to your teacher. Please note that you need to keep the same level of details as in the previous subsection. Note: This section has a bonus you may chose to implement}
  
%% -----------------  
\section{Analysis and Detailed Functionality}
\subsection{Thread identifiers}

For the first part of the task we will change the definition of \lstinline|TID_INCREMENT| to 5 instead of the existing 4. This will alter the functionality of the \lstinline|_ThreadSystemGetNextTid| such as to produce thread id numbers that are multiples of 5. 

For the second part of the task we will change \lstinline{_ThreadInit} to initialize the newly added \lstinline|CreationCpuApicId| field. The change will be as follows:

\begin{lstlisting}
 {
    ...
    pThread->Id = _ThreadSystemGetNextTid();
    pThread->State = ThreadStateBlocked;
    pThread->Priority = Priority;
    
    // ADDED lines:
    pThread->CreationCpuApicId = GetCurrentPcpu()->ApicId;
    ...
 }
\end{lstlisting}


\subsection{Account for number of threads created}

We will change \lstinline|_ThreadInit| to initialize needed fields we add for this task.

The changes may be similar to: 
\begin{lstlisting}
 {
    ...
    pThread->Id = _ThreadSystemGetNextTid();
    pThread->State = ThreadStateBlocked;
    pThread->Priority = Priority;
    
    // ADDED lines:
    PTHREAD currentThread = GetCurrentThread();
    pThread->ParentId = currentThread ? currentThread->Id : 0;
    pThread->NumberOfActiveChildren = 0;

    ...
 }
\end{lstlisting}

Note that \lstinline|_ThreadInit| is also called in \lstinline|ThreadSystemInitMainForCurrentCPU|, where don't yet have
a ``current thread'', so \lstinline|GetCurrentThread()| will return \lstinline|NULL|. This is why we need to check the returned value
and assign 0 to \lstinline|pThread->ParentId|.

We will modify the \lstinline|ThreadCreateEx| function to count the number of active children for a given thread as follows:
\begin{lstlisting}
... 
else
{
    GetCurrentThread()->NumberOfChildrenCreated++; 
    InterlockedIncrement(GetCurrentThread()->NumberOfActiveChildren); 
    ThreadUnblock(pThread);
}
... 
\end{lstlisting}

 We chose to do the increment before unblocking child because that is the place where we know for sure the thread will be initialized successfully. 
 
 We will implement \lstinline|_ThreadReferenceByTid| to iterate over the global list of threads and return the thread with the requested ID. The function will use the following algorithm:
 
 \begin{lstlisting}
  PTHREAD _ThreadReferenceByTid( TID Tid)
  {
    \\...declarations
    LockAcquire(&m_threadSystemData.AllThreadsLock, &oldState);
   
    pListEntry = m_threadSystemData.AllThreadsList.Flink;
    while (pListEntry != &m_threadSystemData.AllThreadsList)
    {
        thread = CONTAINING_RECORD(pListEntry, THREAD, AllList );
        if(thread->Id == Tid)
        {
            _ThreadReference(thread);
            LockRelease(&m_threadSystemData.AllThreadsLock, oldState );
            return thread;
        }
        pListEntry = pListEntry->Flink
    }
   
    LockRelease(&m_threadSystemData.AllThreadsLock, oldState );
    return NULL;
  }
 \end{lstlisting}
 We reference the thread before releasing it to avoid a race condition between returning the thread and it being freed.
 
 We now need to just add the messages. For the first message we will modify the \lstinline|ThreadCreateEx| function to display the required message using \lstinline|LOG|.
 
 \begin{lstlisting}
... 
else
{
    GetCurrentThread()->NumberOfChildrenCreated++; 
    InterlockedIncrement(GetCurrentThread()->NumberOfActiveChildren);
    LOG("Thread [ID=%d] is the Xth thread created by" \
        "thread [ID=%d] on CPU [%d]",
        pThread->Id, GetCurrentThread()->Id, 
        pThread->CreationCpuApicId
        );
     
    ThreadUnblock(pThread);
    ... 
}

\end{lstlisting}
 
The second message should be displayed in the \lstinline{_ThreadExit} function. This function runs in the context of the child process. We need to use \lstinline|_ThreadReferenceByTid| to get a pointer to the parent. After we get the pointer we will also decrement the \lstinline|NumberOfActiveChildren| field for the parent.

The changes required are similar to the following code:
\begin{lstlisting}
...
pThread = GetCurrentThread();
pParent = _ThreadReferenceByTid(pThread->ParentId);

if(!pParent)
{
   LOG("Thread [ID=%d] created on CPU [ID=%d]" ]
       "is finishing on CPU [ID=%d], while it's parent"\
       "thread is already destroyed!.",
       pThread->Tid,
       PThread->CreationCpuApicId,
       GetCurrentPcpu()->ApicId);
}
else
{
    LOG("Thread [ID=%d] created on CPU [ID=%d]" \
       "is finishing on CPU [ID=%d], while it's parent"\
       "thread [ID=%d] still has more %d child threads",
       pThread->Tid,
       PThread->CreationCpuApicId,
       GetCurrentPcpu()->ApicId,
       pParent->Tid,
       InterlockedDecrement(&pParent->NumberOfActiveChildren);
    _ThreadDereference(pParent);
}

CpuIntrDisable();
...
\end{lstlisting}
 
We use \lstinline|InterlockedDecrement| to mark that this child becomes inactive. The function returns the decremented value so the print works correctly.
Due to how we implemented \lstinline |_ThreadReferenceByTid| we need to dereference the parent if we were able to retrieve the pointer to it.


\subsection{Round robin scheduler}
  \textcolor{red}{This subsection is left intentionally blank. It is your task to fill this section in before presenting the document to your teacher. Please note that you need to keep the same level of details as in the previous subsection.Note: This section has a bonus you may chose to implement } 
 
%% -----------------  
\section{Explanation of design decisions}
 \subsection{Thread identifiers}
 This design for this requirement was direct. No other alternatives were considered.
 
 \subsection{Account for number of threads created} 
 Two viable alternatives were considered for accessing the parent thread from the child context on \lstinline|_ThreadExit|:
 \begin{itemize}
     \item Store a referenced pointer to the parent
     \item Store the id of the parent
 \end{itemize}
 
 Both ideas work in practice. Storing a reference to the parent makes the code faster because we have direct access to the parent so we don't perform the look-up on the threads list. The main draw back is that it introduces a severe memory penalty; even if the parent thread finishes execution, it will be cleaned only when all of it's descendants will finish execution. Storing the id of the parent instead of the pointer changes the requirement by altering the message in case the parent already terminated but has no memory consumption issues.
 
 \subsection{Round robin scheduler}
  \textcolor{red}{This subsection is left intentionally blank. It is your task to fill this section in before presenting the document to your teacher. Write here any design decisions you made.} 
 
  
%% -----------------
%% -----------------
\chapter{Tests}
\section{Adding a new test to HAL9000}

The functionality added in this this project may be tested by adding a new command to HAL9000. Existing commands may be seen in \textit{cmd\_interpreter.c} in the \lstinline|COMMANDS| array. 

HAL9000 has a \textit{run} command that allows the execution of tests by name. The tests are executed by the \lstinline|CmdRunTest| function. Tests for the Threads module can be found in the \lstinline|THREADS_TEST| array in the \textit{test\_thread.c} file. New tests can be added as an entry in this array. Implementation for the test should also be added in the \textit{test\_threads.c} file.  

%% -----------------
\section{Test-case design}

\subsection{Creation of multiple threads}

We are required to create a tree of threads, each leaf level having less children then the parent level. 

Creating threads can be done using the \lstinline|ThreadCreate| function. A parameter may be passed to the created thread using the \lstinline|Context| parameter of \lstinline|ThreadCreate|.


We need to create two new files, \textit{test\_lp.c} and \textit{text\_lp.h}. The header file will contain a single function definition for the test.  All our implementation goes in the newly created \textit{test\_lp.c} file. 

We will declare a new global variable to count the number of created tests during the test execution. 
\begin{lstlisting}
static volatile long gNumberOfThreads;
\end{lstlisting}

After this we will create a new function as follows:
\begin{lstlisting}
STATUS
(__cdecl _ThreadLpTest)(
    IN_OPT      PVOID       Context
    )
{
   int numberOfChildren = (int)Context;
   int i;

   for(i =0; i< numberOfChildren; i++)
   {
        PTHREAD thread;
        char thName[MAX_PATH];
        snprintf(thName, MAX_PATH, "ThreadLp-%d",
            InterlockedIncrement(&gNumberOfThreads);
            );

        status = ThreadCreate(thName,
                    ThreadPriorityDefault,
                    _ThreadLpTest,
                    numberOfChildren-1,
                    &thread
                  );
        if (!SUCCEEDED(status))
        {
            LOG_FUNC_ERROR("ThreadCreate", status);
        }
        else
        {
            ThreadCloseHandle(thread);
        }
   }
}
\end{lstlisting}

Our function creates threads that perform the same task as itself but with the context decremented. To start the test, we just need to directly call \lstinline|_ThreadLpTest| with \lstinline|Context| set to 5. 

\subsection{Adding synchronization mechanisms}

HAL9000 already contains an implementation of a function that waits for a thread to finish execution. This function is \lstinline|ThreadWaitForTermination|. To add synchronization the previous test just need to create all the child threads and before exiting the function call \lstinline|ThreadWaitForTermination| on all child handles. We need to store the child handles in a dynamically allocated array. Dynamic memory allocation can be done using \lstinline|ExAllocatePoolWithTag|

\textcolor{red}{This subsection is left intentionally blank. It is your task to fill this section in before presenting the document to your teacher. Here you should create your pseudocode for you use ThreadWaitForTermination to solve the requirement.}

\end{document}
